import psycopg


async def setup_item_table(db_url: str) -> bool:
    # Connect to an existing database
    with psycopg.connect(db_url) as conn:
        # Open a cursor to perform database operations
        with conn.cursor() as cur:
            # Execute a command: this creates a new table
            cur.execute("""
                    CREATE TABLE item_table (
                        id BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1000) PRIMARY KEY,
                        cid bigint NOT NULL,
                        item text NOT NULL,
                        identifier varchar(256) NOT NULL,
                        created_at timestamp with time zone NOT NULL,
                        updated_at timestamp with time zone NOT NULL)
                        IF NOT EXISTS;
                    """)

            conn.commit()
    return True


async def select_all_items(db_url: str, identifier: str) -> list:
    async with await psycopg.AsyncConnection.connect(db_url) as conn:
        async with conn.cursor() as cur:
            await cur.execute(
                """SELECT cid,
                item,
                created_at,
                updated_at FROM item_table WHERE identifier = %s ORDER BY created_at DESC""",
                identifier)
            await cur.fetchall()
            async for record in cur:
                print(record)
    return [cur]


async def select_item_by_item_identifier_cid(
        db_url: str, item: str, identifier: str, cid: str) -> str:
    async with await psycopg.AsyncConnection.connect(db_url) as conn:
        async with conn.cursor() as cur:
            await cur.execute(
                """SELECT id FROM item_table WHERE item = %s AND identifier = %s AND cid = %s """,
                (item, identifier, cid))
            await cur.fetchone()
    return cur[0]


async def insert_item(
        db_url: str, cid: str, item: str, identifier: str) -> bool:
    # Connect to an existing database
    async with await psycopg.AsyncConnection.connect(db_url) as conn:
        # Open a cursor to perform database operations
        async with conn.cursor() as cur:
            # Pass data to fill a query placeholders and let Psycopg perform
            # the correct conversion (no SQL injections!)
            cur.execute(
                """INSERT INTO item_table (cid,
                item,
                identifier,
                created_at,
                updated_at) VALUES (%s, %s, %s, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)""",
                (cid, item, identifier))
            # Make the changes to the database persistent
            cur.commit()
    return True


async def update_item_by_id(
        db_url: str,
        item_id: str,
        cid: str,
        item: str,
        identifier: str) -> bool:
    # Connect to an existing database
    async with await psycopg.AsyncConnection.connect(db_url) as conn:
        # Open a cursor to perform database operations
        async with conn.cursor() as cur:
            # Pass data to fill a query placeholders and let Psycopg perform
            # the correct conversion (no SQL injections!)
            cur.execute(
                """UPDATE item_table SET item = %s,
                 updated_at = current_timestamp WHERE item_id = %s AND cid = %s AND id = %s """,
                (item, item_id, cid, identifier))
            # Make the changes to the database persistent
            cur.commit()
    return True


async def delete_item_by_id(
        db_url: str, item_id: str, cid: str, identifier: str) -> bool:
    # Connect to an existing database
    async with await psycopg.AsyncConnection.connect(db_url) as conn:
        # Open a cursor to perform database operations
        async with conn.cursor() as cur:
            # Pass data to fill a query placeholders and let Psycopg perform
            # the correct conversion (no SQL injections!)
            cur.execute(
                """DELETE FROM item_table WHERE id = %s AND cid = %s AND identifier = %s """,
                (item_id, cid, identifier))
            # Make the changes to the database persistent
            cur.commit()

    return True
